# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# Sample workflow for building and deploying a Jekyll site to GitHub Pages
name: Deploy Jekyll site to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write  # Need write access to push Bluesky URI updates back to posts
  pages: write
  id-token: write
  models: read

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    outputs:
      page-url: ${{ steps.deployment.outputs.page_url }}
      new-posts: ${{ steps.detect.outputs.new-posts }}
      has-new-posts-without-bluesky: ${{ steps.detect.outputs.has-new-posts-without-bluesky }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      - name: Detect new posts without Bluesky URI
        id: detect
        run: |
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Find new posts in _posts (only additions, not modifications)
          NEW_POSTS=$(git diff --name-only --diff-filter=A HEAD~1 HEAD | grep "^_posts/.*\.md\?$" || true)
          echo "New posts: $NEW_POSTS"

          # Check if any new posts don't have blueskyPostURI
          HAS_NEW_POSTS_WITHOUT_BLUESKY="false"
          NEW_POSTS_WITHOUT_BLUESKY=""

          if [ ! -z "$NEW_POSTS" ]; then
            for post in $NEW_POSTS; do
              if [ -f "$post" ]; then
                # Check if post has blueskyPostURI in frontmatter (only between --- markers)
                FRONTMATTER=$(awk '/^---$/{if(seen){exit} seen=1; next} seen{print}' "$post")
                if ! echo "$FRONTMATTER" | grep -q "blueskyPostURI:"; then
                  echo "Found new post without Bluesky URI: $post"
                  HAS_NEW_POSTS_WITHOUT_BLUESKY="true"
                  if [ -z "$NEW_POSTS_WITHOUT_BLUESKY" ]; then
                    NEW_POSTS_WITHOUT_BLUESKY="$post"
                  else
                    NEW_POSTS_WITHOUT_BLUESKY="$NEW_POSTS_WITHOUT_BLUESKY,$post"
                  fi
                else
                  echo "Post already has Bluesky URI: $post"
                fi
              fi
            done
          fi

          echo "new-posts=$NEW_POSTS_WITHOUT_BLUESKY" >> $GITHUB_OUTPUT
          echo "has-new-posts-without-bluesky=$HAS_NEW_POSTS_WITHOUT_BLUESKY" >> $GITHUB_OUTPUT
          echo "Has new posts without Bluesky: $HAS_NEW_POSTS_WITHOUT_BLUESKY"
          echo "New posts without Bluesky: $NEW_POSTS_WITHOUT_BLUESKY"

      - name: Setup Ruby
        # https://github.com/ruby/setup-ruby/releases/tag/v1.220.0
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1' # Not needed with a .ruby-version file
          bundler-cache: true # runs 'bundle install' and caches installed gems automatically
          cache-version: 1 # Increment this number if you need to re-download cached gems
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5
      - name: Build with Jekyll
        # Outputs to the './_site' directory by default
        run: bundle exec jekyll build --baseurl "${{ steps.pages.outputs.base_path }}"
        env:
          JEKYLL_ENV: production
      - name: Upload artifact
        # Automatically uploads an artifact from the './_site' directory by default
        uses: actions/upload-pages-artifact@v3
        with:
          name: github-pages-initial
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        with:
          artifact_name: github-pages-initial

  bluesky-social:
    name: Post to Bluesky
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: needs.build-and-deploy.outputs.has-new-posts-without-bluesky == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Process new posts and post to Bluesky
        id: process-posts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PAGE_URL: ${{ needs.build-and-deploy.outputs.page-url }}
        run: |
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq

          # Initialize variables
          BLUESKY_TEXT=""
          POST_FILE=""

          # Process each new post
          IFS=',' read -ra POSTS <<< "${{ needs.build-and-deploy.outputs.new-posts }}"
          for post_file in "${POSTS[@]}"; do
            echo "Processing $post_file"

            # Extract post title and description. maybe qutotes maybe not..
            POST_TITLE=$(grep "^title:" "$post_file" | sed 's/title: *//; s/^"\(.*\)"$/\1/')
            POST_DESCRIPTION=$(grep "^description:" "$post_file" | sed 's/description: *//; s/^"\(.*\)"$/\1/')

            # Extract categories and tags for context
            POST_CATEGORY=$(grep "^category:" "$post_file" | sed 's/category: *//')
            POST_TAGS=$(grep "^tags:" "$post_file" | sed 's/tags: *//')

            # Extract and clean post content (first few paragraphs)
            # Remove frontmatter and get first 500 characters of actual content
            POST_CONTENT=$(awk '
              BEGIN { in_frontmatter = 0; content_started = 0; }
              /^---$/ {
                if (in_frontmatter == 1) { content_started = 1; }
                in_frontmatter = !in_frontmatter;
                next;
              }
              content_started == 1 && in_frontmatter == 0 {
                # Skip empty lines at start
                if (NF == 0 && length(content) == 0) next;
                # Skip markdown headers and links for cleaner text
                gsub(/^#+\s*/, "");
                gsub(/\[([^\]]*)\]\([^\)]*\)/, "\\1");
                gsub(/\*\*([^\*]*)\*\*/, "\\1");
                gsub(/\*([^\*]*)\*/, "\\1");
                content = content " " $0;
                if (length(content) > 500) exit;
              }
              END { print substr(content, 1, 500); }
            ' "$post_file")

            # Convert file path to URL path
            POST_URL_PATH=$(echo "$post_file" | sed 's|_posts/||' | sed 's|\.mdx\?$||')
            ENCODED_TITLE=$(echo "$POST_TITLE" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/--*/-/g')
            POST_URL="${PAGE_URL}${POST_CATEGORY}/${ENCODED_TITLE}/"

            echo "Post title: $POST_TITLE"
            echo "Post description: $POST_DESCRIPTION"
            echo "Post URL: $POST_URL"
            echo "Post category: $POST_CATEGORY"
            echo "Post content preview: ${POST_CONTENT:0:200}..."

            # Create enhanced prompt with post context
            PROMPT="Write a short, engaging social media post (under 225 characters) for a new blog post. Use US english, never use emdash and only use hashtags sparingly and if they fit into the body of the text in a way that reads like a sentence. Title: $POST_TITLE. Description: $POST_DESCRIPTION. Category: $POST_CATEGORY. Content preview: $POST_CONTENT. Make it conversational and include relevant hashtags. Don't include the URL."

            AI_RESPONSE=$(curl -s "https://models.github.ai/inference/chat/completions" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -d "{
                \"messages\": [
                  {
                    \"role\": \"user\",
                    \"content\": $(echo "$PROMPT" | jq -R -s .)
                  }
                ],
                \"model\": \"openai/gpt-4.1\"
              }")

            echo "ai response:  $AI_RESPONSE"

            # Extract the message from the response
            AI_MESSAGE=$(echo "$AI_RESPONSE" | jq -r '.choices[0].message.content')
            BLUESKY_TEXT="${AI_MESSAGE} ${POST_URL}"
            POST_FILE="$post_file"

            echo "Generated message: $BLUESKY_TEXT"

            # Set outputs for next step
            echo "BLUESKY_TEXT=$BLUESKY_TEXT" >> $GITHUB_OUTPUT
            echo "POST_FILE=$POST_FILE" >> $GITHUB_OUTPUT

            # Only process one post for now
            break
          done

      - name: Post to Bluesky
        if: steps.process-posts.outputs.BLUESKY_TEXT != ''
        id: bluesky-post
        run: |
          # Install AT Protocol client and GitHub Actions core
          npm install @atproto/api @actions/core

          # Create a Node.js script to post to Bluesky and capture the response
          cat > post_to_bluesky.js << 'EOF'
          const { BskyAgent, RichText } = require('@atproto/api');
          const core = require('@actions/core');

          async function main() {
            const agent = new BskyAgent({
              service: 'https://bsky.social'
            });

            try {
              await agent.login({
                identifier: process.env.BSKY_IDENTIFIER,
                password: process.env.BSKY_PASSWORD
              });

              // Use RichText to properly detect links and create facets
              const richText = new RichText({
                text: process.env.POST_TEXT
              });

              // This will detect URLs and create proper facets for links
              await richText.detectFacets(agent);

              const response = await agent.post({
                text: richText.text,
                facets: richText.facets,
                createdAt: new Date().toISOString()
              });

              console.log('Post successful!');
              console.log('URI:', response.uri);
              console.log('CID:', response.cid);

              // Set outputs for GitHub Actions
              core.setOutput('uri', response.uri);
              core.setOutput('cid', response.cid);
              core.setOutput('url', `https://bsky.app/profile/${process.env.BSKY_IDENTIFIER}/post/${response.uri.split('/').pop()}`);

            } catch (error) {
              console.error('Error posting to Bluesky:', error);
              process.exit(1);
            }
          }

          main();
          EOF

          # Run the script
          node post_to_bluesky.js
        env:
          BSKY_IDENTIFIER: ${{ secrets.BLUESKY_IDENTIFIER }}
          BSKY_PASSWORD: ${{ secrets.BLUESKY_PASSWORD }}
          POST_TEXT: ${{ steps.process-posts.outputs.BLUESKY_TEXT }}

      - name: Update post with Bluesky URI
        if: steps.bluesky-post.outputs.uri != ''
        id: update-posts-in-github
        run: |
          # Update the post file with the Bluesky URI
          POST_FILE="${{ steps.process-posts.outputs.POST_FILE }}"

          # Find the line with firstprop: first and add blueskyPostURI after it
          sed -i "/^firstprop: first$/a blueskyPostURI: \"${{ steps.bluesky-post.outputs.uri }}\"" "$POST_FILE"

          echo "Updated $POST_FILE with Bluesky URI: ${{ steps.bluesky-post.outputs.uri }}"

      - name: Commit updated post files
        if: steps.bluesky-post.outputs.uri != ''
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add _posts/
          git diff --staged --quiet || git commit -m "Add Bluesky post URI to new blog post"
          git push

  rebuild-after-bluesky:
    name: Rebuild After Bluesky Update
    runs-on: ubuntu-latest
    needs: bluesky-social
    if: always() && needs.bluesky-social.result == 'success'
    steps:
      - name: Checkout updated code
        uses: actions/checkout@v4
        with:
          ref: main
      - name: Setup Ruby
        # https://github.com/ruby/setup-ruby/releases/tag/v1.220.0
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1' # Not needed with a .ruby-version file
          bundler-cache: true # runs 'bundle install' and caches installed gems automatically
          cache-version: 1 # Increment this number if you need to re-download cached gems
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5
      - name: Build with Jekyll
        # Outputs to the './_site' directory by default
        run: bundle exec jekyll build --baseurl "${{ steps.pages.outputs.base_path }}"
        env:
          JEKYLL_ENV: production
      - name: Upload artifact
        # Automatically uploads an artifact from the './_site' directory by default
        uses: actions/upload-pages-artifact@v3
        with:
          name: github-pages-final
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        with:
          artifact_name: github-pages-final
