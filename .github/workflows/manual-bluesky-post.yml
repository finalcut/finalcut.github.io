name: Manual Bluesky Post

on:
  workflow_dispatch:
    inputs:
      post_file:
        description: 'Blog post filename (e.g., 2025-11-10-my-blog-post.md)'
        required: true
        type: string
      custom_message:
        description: 'Optional custom message (if empty, will generate one with AI)'
        required: false
        type: string
      force_repost:
        description: 'Force repost even if blueskyPostURI already exists'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  models: read

jobs:
  post-to-bluesky:
    name: Post to Bluesky
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract post content and prepare message
        id: prepare
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq

          POST_PATH="_posts/${{ github.event.inputs.post_file }}"

          if [ ! -f "$POST_PATH" ]; then
            echo "Error: Post file $POST_PATH not found"
            exit 1
          fi

          # Extract title and excerpt for message generation
          TITLE=$(grep "^title:" "$POST_PATH" | sed 's/^title: *//; s/^["'\'']*//; s/["'\'']*$//')
          EXCERPT=$(grep "^excerpt:" "$POST_PATH" | sed 's/^excerpt: *//; s/^["'\'']*//; s/["'\'']*$//')
          DESCRIPTION=$(grep "^description:" "$POST_PATH" | sed 's/description: *//; s/^"\(.*\)"$/\1/')
          CATEGORY=$(grep "^category:" "$POST_PATH" | sed 's/category: *//')

          # Extract post content for context
          POST_CONTENT=$(awk '
            BEGIN { in_frontmatter = 0; content_started = 0; }
            /^---$/ {
              if (in_frontmatter == 1) { content_started = 1; }
              in_frontmatter = !in_frontmatter;
              next;
            }
            content_started == 1 && in_frontmatter == 0 {
              if (NF == 0 && length(content) == 0) next;
              gsub(/^#+\s*/, "");
              gsub(/\[([^\]]*)\]\([^\)]*\)/, "\\1");
              gsub(/\*\*([^\*]*)\*\*/, "\\1");
              gsub(/\*([^\*]*)\*/, "\\1");
              content = content " " $0;
              if (length(content) > 500) exit;
            }
            END { print substr(content, 1, 500); }
          ' "$POST_PATH")

          # Generate URL using filename (matching Jekyll's behavior)
          FILENAME=$(basename "${{ github.event.inputs.post_file }}" .md)
          URL_SLUG=$(echo "$FILENAME" | sed 's/^[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}-//')

          # Use the correct site URL and category for the post URL
          SITE_URL="https://rawlinson.us"
          POST_CATEGORY="${CATEGORY:-blogging}"
          POST_URL="${SITE_URL}/${POST_CATEGORY}/${URL_SLUG}/#page-title"

          # Calculate the exact URL length and determine maximum AI response length
          URL_LENGTH=$(echo -n "$POST_URL" | wc -c)
          # Reserve 5 characters for the space and any punctuation between message and URL
          SPACE_BUFFER=5
          MAX_AI_LENGTH=$((300 - URL_LENGTH - SPACE_BUFFER))

          # Safety check: ensure we have at least 50 characters for the AI response
          if [ "$MAX_AI_LENGTH" -lt 50 ]; then
            echo "Warning: URL is very long ($URL_LENGTH chars). Setting minimum AI length to 50."
            MAX_AI_LENGTH=50
          fi

          echo "Post URL: $POST_URL"
          echo "URL length: $URL_LENGTH characters"
          echo "Max AI response length: $MAX_AI_LENGTH characters"

          if [ -n "${{ github.event.inputs.custom_message }}" ]; then
            MESSAGE="${{ github.event.inputs.custom_message }} $POST_URL"
            echo "Using custom message with URL"
          else
            echo "Generating AI message"
            # Create enhanced prompt with calculated character limit
            PROMPT="Write a thoughtful, natural introduction (under $MAX_AI_LENGTH characters) for a blog post share. Create a genuine summary that sparks curiosity through interesting details, not questions or calls to action. Avoid click-bait language, exclamation points, and phrases like 'you need to', 'must read', 'will blow your mind', etc. Write in a conversational, informative tone like you're telling a friend about something interesting you learned. Use US English, avoid em-dashes, and only include hashtags if they naturally fit the sentence flow. The response must be under $MAX_AI_LENGTH characters as a URL will be appended. Title: $POST_TITLE. Description: $POST_DESCRIPTION. Category: $POST_CATEGORY. Content preview: $POST_CONTENT. The URL will be added automatically."

            AI_RESPONSE=$(curl -s "https://models.github.ai/inference/chat/completions" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -d "{
                \"messages\": [
                  {
                    \"role\": \"user\",
                    \"content\": $(echo "$PROMPT" | jq -R -s .)
                  }
                ],
                \"model\": \"openai/gpt-4.1\"
              }")

            echo "AI response: $AI_RESPONSE"

            # Check if the response contains an error
            API_ERROR=$(echo "$AI_RESPONSE" | jq -r '.error.message // empty')
            if [ -n "$API_ERROR" ]; then
              echo "❌ GitHub AI API Error: $API_ERROR"
              echo "Full error response: $AI_RESPONSE"
              AI_MESSAGE=""  # Set to empty to trigger fallback
            else
              # Extract the message from the response
              AI_MESSAGE=$(echo "$AI_RESPONSE" | jq -r '.choices[0].message.content // empty')
              if [ -z "$AI_MESSAGE" ] || [ "$AI_MESSAGE" = "null" ]; then
                echo "❌ AI API returned empty or null content"
                echo "Response structure: $AI_RESPONSE"
              fi
            fi

            # Check if AI response is null or empty, use fallbacks
            if [ "$AI_MESSAGE" = "null" ] || [ -z "$AI_MESSAGE" ]; then
              echo "AI response was null or empty, using fallback logic"

              # Check if description has a value
              if [ -n "$POST_DESCRIPTION" ] && [ "$POST_DESCRIPTION" != "" ]; then
                echo "Using description from frontmatter"
                AI_MESSAGE="$POST_DESCRIPTION"
              else
                # Check if excerpt has a value
                POST_EXCERPT=$(grep "^excerpt:" "$POST_PATH" | sed 's/excerpt: *//; s/^"\(.*\)"$/\1/')
                if [ -n "$POST_EXCERPT" ] && [ "$POST_EXCERPT" != "" ]; then
                  echo "Using excerpt from frontmatter"
                  AI_MESSAGE="$POST_EXCERPT"
                else
                  # Use first 200 characters of clean text content
                  echo "Using first 200 characters of post content"
                  CLEAN_CONTENT=$(echo "$POST_CONTENT" | sed 's/!\[[^\]]*\]([^)]*)//g; s/\[[^\]]*\]([^)]*)//g; s/\*\*//g; s/\*//g; s/#\+//g' | tr -s ' ' | sed 's/^ *//; s/ *$//')
                  AI_MESSAGE=$(echo "$CLEAN_CONTENT" | cut -c1-200)
                fi
              fi
            fi

            MESSAGE="${AI_MESSAGE} ${POST_URL}"
          fi

          echo "MESSAGE=$MESSAGE" >> $GITHUB_OUTPUT
          echo "Generated message: $MESSAGE"

      - name: Post to Bluesky
        id: bluesky
        uses: finalcut/bluesky-post-action@feature/add-post-outputs
        env:
          BSKY_IDENTIFIER: ${{ secrets.BLUESKY_IDENTIFIER }}
          BSKY_PASSWORD: ${{ secrets.BLUESKY_PASSWORD }}
        with:
          post: ${{ steps.prepare.outputs.MESSAGE }}
          service: https://bsky.social

      - name: Update post with Bluesky URL
        if: steps.bluesky.outputs.url != ''
        run: |
          POST_PATH="_posts/${{ github.event.inputs.post_file }}"
          BLUESKY_URL="${{ steps.bluesky.outputs.url }}"

          # Check if post already has blueskyPostURL
          if grep -q "blueskyPostURL:" "$POST_PATH"; then
            echo "Post already has blueskyPostURL. Replacing existing entries."
            # Remove all existing blueskyPostURL lines and add the new one
            awk -v uri="$BLUESKY_URL" '
            BEGIN { in_frontmatter = 0; inserted = 0 }
            /^---$/ {
                if (!in_frontmatter) {
                    in_frontmatter = 1
                    print $0
                } else if (!inserted) {
                    print "blueskyPostURL: " uri
                    print $0
                    inserted = 1
                } else {
                    print $0
                }
                next
            }
            # Skip existing blueskyPostURL lines
            /^blueskyPostURL:/ && in_frontmatter { next }
            { print $0 }
            ' "$POST_PATH" > "$POST_PATH.tmp" && mv "$POST_PATH.tmp" "$POST_PATH"
          else
            # Add new blueskyPostURL to frontmatter
            echo "Adding new blueskyPostURL to frontmatter."
            awk -v uri="$BLUESKY_URL" '
            BEGIN { in_frontmatter = 0; inserted = 0 }
            /^---$/ {
                if (!in_frontmatter) {
                    in_frontmatter = 1
                    print $0
                } else if (!inserted) {
                    print "blueskyPostURL: " uri
                    print $0
                    inserted = 1
                } else {
                    print $0
                }
                next
            }
            { print $0 }
            ' "$POST_PATH" > "$POST_PATH.tmp" && mv "$POST_PATH.tmp" "$POST_PATH"
          fi

          echo "Updated $POST_PATH with Bluesky URL: $BLUESKY_URL"

          # Commit the change
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add "$POST_PATH"
          git commit -m "Add Bluesky post URL to ${{ github.event.inputs.post_file }}"
          git push

  rebuild-site:
    name: Rebuild Site After Bluesky Update
    runs-on: ubuntu-latest
    needs: post-to-bluesky
    if: always() && needs.post-to-bluesky.result == 'success'
    permissions:
      contents: read
      pages: write
      id-token: write
    steps:
      - name: Checkout updated code
        uses: actions/checkout@v4
        with:
          ref: main
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1'
          bundler-cache: true
          cache-version: 1
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5
      - name: Build with Jekyll
        run: bundle exec jekyll build --baseurl "${{ steps.pages.outputs.base_path }}"
        env:
          JEKYLL_ENV: production
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          name: github-pages-manual
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        with:
          artifact_name: github-pages-manual
